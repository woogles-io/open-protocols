// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.32.0
// 	protoc        v4.25.1
// source: cgh/cgh.proto

package cgh

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ChallengeRule int32

const (
	ChallengeRule_SINGLE ChallengeRule = 0
	ChallengeRule_DOUBLE ChallengeRule = 1
	// FIVE_POINT is five points per word challenged.
	ChallengeRule_FIVE_POINT ChallengeRule = 2
	// TEN_POINT is ten points per play challenged.
	ChallengeRule_TEN_POINT ChallengeRule = 3
	ChallengeRule_TRIPLE    ChallengeRule = 4
)

// Enum value maps for ChallengeRule.
var (
	ChallengeRule_name = map[int32]string{
		0: "SINGLE",
		1: "DOUBLE",
		2: "FIVE_POINT",
		3: "TEN_POINT",
		4: "TRIPLE",
	}
	ChallengeRule_value = map[string]int32{
		"SINGLE":     0,
		"DOUBLE":     1,
		"FIVE_POINT": 2,
		"TEN_POINT":  3,
		"TRIPLE":     4,
	}
)

func (x ChallengeRule) Enum() *ChallengeRule {
	p := new(ChallengeRule)
	*p = x
	return p
}

func (x ChallengeRule) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ChallengeRule) Descriptor() protoreflect.EnumDescriptor {
	return file_cgh_cgh_proto_enumTypes[0].Descriptor()
}

func (ChallengeRule) Type() protoreflect.EnumType {
	return &file_cgh_cgh_proto_enumTypes[0]
}

func (x ChallengeRule) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ChallengeRule.Descriptor instead.
func (ChallengeRule) EnumDescriptor() ([]byte, []int) {
	return file_cgh_cgh_proto_rawDescGZIP(), []int{0}
}

type EndgameRackPointsRule int32

const (
	EndgameRackPointsRule_DOUBLE_PTS    EndgameRackPointsRule = 0
	EndgameRackPointsRule_PLUSMINUS_PTS EndgameRackPointsRule = 1
)

// Enum value maps for EndgameRackPointsRule.
var (
	EndgameRackPointsRule_name = map[int32]string{
		0: "DOUBLE_PTS",
		1: "PLUSMINUS_PTS",
	}
	EndgameRackPointsRule_value = map[string]int32{
		"DOUBLE_PTS":    0,
		"PLUSMINUS_PTS": 1,
	}
)

func (x EndgameRackPointsRule) Enum() *EndgameRackPointsRule {
	p := new(EndgameRackPointsRule)
	*p = x
	return p
}

func (x EndgameRackPointsRule) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EndgameRackPointsRule) Descriptor() protoreflect.EnumDescriptor {
	return file_cgh_cgh_proto_enumTypes[1].Descriptor()
}

func (EndgameRackPointsRule) Type() protoreflect.EnumType {
	return &file_cgh_cgh_proto_enumTypes[1]
}

func (x EndgameRackPointsRule) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EndgameRackPointsRule.Descriptor instead.
func (EndgameRackPointsRule) EnumDescriptor() ([]byte, []int) {
	return file_cgh_cgh_proto_rawDescGZIP(), []int{1}
}

type PlayerInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// nickname should be a nickname the player is known by; but it can also be
	// their full name. It should be required per player.
	Nickname string `protobuf:"bytes,1,opt,name=nickname,proto3" json:"nickname,omitempty"`
	// real_name can potentially be optional.
	RealName string `protobuf:"bytes,2,opt,name=real_name,json=realName,proto3" json:"real_name,omitempty"`
}

func (x *PlayerInfo) Reset() {
	*x = PlayerInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cgh_cgh_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PlayerInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PlayerInfo) ProtoMessage() {}

func (x *PlayerInfo) ProtoReflect() protoreflect.Message {
	mi := &file_cgh_cgh_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PlayerInfo.ProtoReflect.Descriptor instead.
func (*PlayerInfo) Descriptor() ([]byte, []int) {
	return file_cgh_cgh_proto_rawDescGZIP(), []int{0}
}

func (x *PlayerInfo) GetNickname() string {
	if x != nil {
		return x.Nickname
	}
	return ""
}

func (x *PlayerInfo) GetRealName() string {
	if x != nil {
		return x.RealName
	}
	return ""
}

// CrosswordGameHistory encodes an entire History of a Crossword Game. See
// README for more details.
type CrosswordGameHistory struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// events is a chronological list of gameplay events. An "event" could
	// be defined as what transpires during a player's turn when the clock
	// is hit.
	Events []*CrosswordGameEvent `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	// players is a list of players. It is invalid to have more than one player
	// have the same "nickname". Players are listed from first to last (in order
	// of game play).
	Players []*PlayerInfo `protobuf:"bytes,2,rep,name=players,proto3" json:"players,omitempty"`
	// lexicon is a lexicon code, such as NWL20 or CSW21. There should be a
	// list of commonly accepted lexicon codes.
	Lexicon string `protobuf:"bytes,3,opt,name=lexicon,proto3" json:"lexicon,omitempty"`
	// variant is a variant that describes the rules of the game. This should
	// maybe be an enum.
	Variant string `protobuf:"bytes,4,opt,name=variant,proto3" json:"variant,omitempty"`
	// board_layout should describe the board. If left blank, it should default
	// to a common game board representation. Otherwise, it should be a string
	// representation of the board; see README in this directory for format.
	BoardLayout string `protobuf:"bytes,5,opt,name=board_layout,json=boardLayout,proto3" json:"board_layout,omitempty"`
	// description is a freeform comment section describing the circumstances
	// under which this game were played.
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// letter_distribution should be a string, like "english" or "english_super".
	// XXX: maybe the actual letter distribution?
	LetterDistribution string        `protobuf:"bytes,7,opt,name=letter_distribution,json=letterDistribution,proto3" json:"letter_distribution,omitempty"`
	ChallengeRule      ChallengeRule `protobuf:"varint,8,opt,name=challenge_rule,json=challengeRule,proto3,enum=woogles_open_protocols.ChallengeRule" json:"challenge_rule,omitempty"`
	// starting_cgp is a starting CGP position, if any. See the CGP directory
	// for what constitutes a CGP string. Note that many of the fields in the CGP
	// string, such as lexicon and letter distribution, would be redundant and
	// should be ignored by the implementer in favor of what is in this
	// CrosswordGameHistory message.
	StartingCgp string `protobuf:"bytes,9,opt,name=starting_cgp,json=startingCgp,proto3" json:"starting_cgp,omitempty"`
	// last_known_racks is in order of the players.
	LastKnownRacks []string `protobuf:"bytes,10,rep,name=last_known_racks,json=lastKnownRacks,proto3" json:"last_known_racks,omitempty"`
	// how much time do they have at the start, in seconds. This field shouldn't
	// be required; there will just not be timing info.
	StartingTime []int32 `protobuf:"varint,11,rep,packed,name=starting_time,json=startingTime,proto3" json:"starting_time,omitempty"`
	// what is the time increment per player, in seconds
	TimeIncrements []int32 `protobuf:"varint,12,rep,packed,name=time_increments,json=timeIncrements,proto3" json:"time_increments,omitempty"`
	// / more rules here?
	EndgameRackPointsRule EndgameRackPointsRule `protobuf:"varint,13,opt,name=endgame_rack_points_rule,json=endgameRackPointsRule,proto3,enum=woogles_open_protocols.EndgameRackPointsRule" json:"endgame_rack_points_rule,omitempty"`
	// should this be a ruleset instead? different languages have different rules
	// for what constitutes a "zero" here.
	NumberOfZeroptTurnsToEndGame int32 `protobuf:"varint,14,opt,name=number_of_zeropt_turns_to_end_game,json=numberOfZeroptTurnsToEndGame,proto3" json:"number_of_zeropt_turns_to_end_game,omitempty"`
}

func (x *CrosswordGameHistory) Reset() {
	*x = CrosswordGameHistory{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cgh_cgh_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CrosswordGameHistory) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CrosswordGameHistory) ProtoMessage() {}

func (x *CrosswordGameHistory) ProtoReflect() protoreflect.Message {
	mi := &file_cgh_cgh_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CrosswordGameHistory.ProtoReflect.Descriptor instead.
func (*CrosswordGameHistory) Descriptor() ([]byte, []int) {
	return file_cgh_cgh_proto_rawDescGZIP(), []int{1}
}

func (x *CrosswordGameHistory) GetEvents() []*CrosswordGameEvent {
	if x != nil {
		return x.Events
	}
	return nil
}

func (x *CrosswordGameHistory) GetPlayers() []*PlayerInfo {
	if x != nil {
		return x.Players
	}
	return nil
}

func (x *CrosswordGameHistory) GetLexicon() string {
	if x != nil {
		return x.Lexicon
	}
	return ""
}

func (x *CrosswordGameHistory) GetVariant() string {
	if x != nil {
		return x.Variant
	}
	return ""
}

func (x *CrosswordGameHistory) GetBoardLayout() string {
	if x != nil {
		return x.BoardLayout
	}
	return ""
}

func (x *CrosswordGameHistory) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *CrosswordGameHistory) GetLetterDistribution() string {
	if x != nil {
		return x.LetterDistribution
	}
	return ""
}

func (x *CrosswordGameHistory) GetChallengeRule() ChallengeRule {
	if x != nil {
		return x.ChallengeRule
	}
	return ChallengeRule_SINGLE
}

func (x *CrosswordGameHistory) GetStartingCgp() string {
	if x != nil {
		return x.StartingCgp
	}
	return ""
}

func (x *CrosswordGameHistory) GetLastKnownRacks() []string {
	if x != nil {
		return x.LastKnownRacks
	}
	return nil
}

func (x *CrosswordGameHistory) GetStartingTime() []int32 {
	if x != nil {
		return x.StartingTime
	}
	return nil
}

func (x *CrosswordGameHistory) GetTimeIncrements() []int32 {
	if x != nil {
		return x.TimeIncrements
	}
	return nil
}

func (x *CrosswordGameHistory) GetEndgameRackPointsRule() EndgameRackPointsRule {
	if x != nil {
		return x.EndgameRackPointsRule
	}
	return EndgameRackPointsRule_DOUBLE_PTS
}

func (x *CrosswordGameHistory) GetNumberOfZeroptTurnsToEndGame() int32 {
	if x != nil {
		return x.NumberOfZeroptTurnsToEndGame
	}
	return 0
}

type CrosswordGameEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// nickname is the nickname (in PlayerInfo) of the player who passed.
	Nickname string `protobuf:"bytes,1,opt,name=nickname,proto3" json:"nickname,omitempty"`
	// rack is the rack the player had when they caused this event to occur.
	Rack string `protobuf:"bytes,2,opt,name=rack,proto3" json:"rack,omitempty"`
	// total_score is the score the player had after this event.
	TotalScore int32 `protobuf:"varint,3,opt,name=total_score,json=totalScore,proto3" json:"total_score,omitempty"`
	// time_remaining_ms is how much time the player had remaining on their clock,
	// after this event. This time should be in seconds.
	TimeRemaining int32 `protobuf:"varint,4,opt,name=time_remaining,json=timeRemaining,proto3" json:"time_remaining,omitempty"`
	// Types that are assignable to Event:
	//
	//	*CrosswordGameEvent_PassEvent
	//	*CrosswordGameEvent_ChallengeEvent
	//	*CrosswordGameEvent_ExchangeEvent
	//	*CrosswordGameEvent_TilePlayEvent
	//	*CrosswordGameEvent_GameEndEvent
	//	*CrosswordGameEvent_OverdrawEvent
	Event isCrosswordGameEvent_Event `protobuf_oneof:"event"`
	// a comment is a freeform comment for this event. Ideally the user can use
	// something like Markdown, but there's no limit placed on what the comment
	// can contain.
	Comment string `protobuf:"bytes,5,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (x *CrosswordGameEvent) Reset() {
	*x = CrosswordGameEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cgh_cgh_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CrosswordGameEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CrosswordGameEvent) ProtoMessage() {}

func (x *CrosswordGameEvent) ProtoReflect() protoreflect.Message {
	mi := &file_cgh_cgh_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CrosswordGameEvent.ProtoReflect.Descriptor instead.
func (*CrosswordGameEvent) Descriptor() ([]byte, []int) {
	return file_cgh_cgh_proto_rawDescGZIP(), []int{2}
}

func (x *CrosswordGameEvent) GetNickname() string {
	if x != nil {
		return x.Nickname
	}
	return ""
}

func (x *CrosswordGameEvent) GetRack() string {
	if x != nil {
		return x.Rack
	}
	return ""
}

func (x *CrosswordGameEvent) GetTotalScore() int32 {
	if x != nil {
		return x.TotalScore
	}
	return 0
}

func (x *CrosswordGameEvent) GetTimeRemaining() int32 {
	if x != nil {
		return x.TimeRemaining
	}
	return 0
}

func (m *CrosswordGameEvent) GetEvent() isCrosswordGameEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (x *CrosswordGameEvent) GetPassEvent() *PassEvent {
	if x, ok := x.GetEvent().(*CrosswordGameEvent_PassEvent); ok {
		return x.PassEvent
	}
	return nil
}

func (x *CrosswordGameEvent) GetChallengeEvent() *ChallengeEvent {
	if x, ok := x.GetEvent().(*CrosswordGameEvent_ChallengeEvent); ok {
		return x.ChallengeEvent
	}
	return nil
}

func (x *CrosswordGameEvent) GetExchangeEvent() *ExchangeEvent {
	if x, ok := x.GetEvent().(*CrosswordGameEvent_ExchangeEvent); ok {
		return x.ExchangeEvent
	}
	return nil
}

func (x *CrosswordGameEvent) GetTilePlayEvent() *TilePlayEvent {
	if x, ok := x.GetEvent().(*CrosswordGameEvent_TilePlayEvent); ok {
		return x.TilePlayEvent
	}
	return nil
}

func (x *CrosswordGameEvent) GetGameEndEvent() *GameEndEvent {
	if x, ok := x.GetEvent().(*CrosswordGameEvent_GameEndEvent); ok {
		return x.GameEndEvent
	}
	return nil
}

func (x *CrosswordGameEvent) GetOverdrawEvent() *OverdrawEvent {
	if x, ok := x.GetEvent().(*CrosswordGameEvent_OverdrawEvent); ok {
		return x.OverdrawEvent
	}
	return nil
}

func (x *CrosswordGameEvent) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

type isCrosswordGameEvent_Event interface {
	isCrosswordGameEvent_Event()
}

type CrosswordGameEvent_PassEvent struct {
	PassEvent *PassEvent `protobuf:"bytes,6,opt,name=pass_event,json=passEvent,proto3,oneof"`
}

type CrosswordGameEvent_ChallengeEvent struct {
	ChallengeEvent *ChallengeEvent `protobuf:"bytes,7,opt,name=challenge_event,json=challengeEvent,proto3,oneof"`
}

type CrosswordGameEvent_ExchangeEvent struct {
	ExchangeEvent *ExchangeEvent `protobuf:"bytes,8,opt,name=exchange_event,json=exchangeEvent,proto3,oneof"`
}

type CrosswordGameEvent_TilePlayEvent struct {
	TilePlayEvent *TilePlayEvent `protobuf:"bytes,9,opt,name=tile_play_event,json=tilePlayEvent,proto3,oneof"`
}

type CrosswordGameEvent_GameEndEvent struct {
	GameEndEvent *GameEndEvent `protobuf:"bytes,10,opt,name=game_end_event,json=gameEndEvent,proto3,oneof"`
}

type CrosswordGameEvent_OverdrawEvent struct {
	OverdrawEvent *OverdrawEvent `protobuf:"bytes,11,opt,name=overdraw_event,json=overdrawEvent,proto3,oneof"`
}

func (*CrosswordGameEvent_PassEvent) isCrosswordGameEvent_Event() {}

func (*CrosswordGameEvent_ChallengeEvent) isCrosswordGameEvent_Event() {}

func (*CrosswordGameEvent_ExchangeEvent) isCrosswordGameEvent_Event() {}

func (*CrosswordGameEvent_TilePlayEvent) isCrosswordGameEvent_Event() {}

func (*CrosswordGameEvent_GameEndEvent) isCrosswordGameEvent_Event() {}

func (*CrosswordGameEvent_OverdrawEvent) isCrosswordGameEvent_Event() {}

// PassEvent happens if the player purposefully passes their turn.
type PassEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *PassEvent) Reset() {
	*x = PassEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cgh_cgh_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PassEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PassEvent) ProtoMessage() {}

func (x *PassEvent) ProtoReflect() protoreflect.Message {
	mi := &file_cgh_cgh_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PassEvent.ProtoReflect.Descriptor instead.
func (*PassEvent) Descriptor() ([]byte, []int) {
	return file_cgh_cgh_proto_rawDescGZIP(), []int{3}
}

// a ChallengeEvent happens only right after a tile play event. Any other
// time it should be considered invalid.
type ChallengeEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// words_challenged is a list of every challenged word.
	WordsChallenged []string `protobuf:"bytes,1,rep,name=words_challenged,json=wordsChallenged,proto3" json:"words_challenged,omitempty"`
	// score_bonus is the bonus points given to the challenged player.
	ScoreBonus int32 `protobuf:"varint,2,opt,name=score_bonus,json=scoreBonus,proto3" json:"score_bonus,omitempty"`
	// play_valid -- was the play valid? If using double challenge, and the
	// challenger was wrong, we do not need to follow the ChallengeEvent
	// with a PassEvent. It should be implied.
	PlayValid bool `protobuf:"varint,3,opt,name=play_valid,json=playValid,proto3" json:"play_valid,omitempty"`
}

func (x *ChallengeEvent) Reset() {
	*x = ChallengeEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cgh_cgh_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ChallengeEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChallengeEvent) ProtoMessage() {}

func (x *ChallengeEvent) ProtoReflect() protoreflect.Message {
	mi := &file_cgh_cgh_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChallengeEvent.ProtoReflect.Descriptor instead.
func (*ChallengeEvent) Descriptor() ([]byte, []int) {
	return file_cgh_cgh_proto_rawDescGZIP(), []int{4}
}

func (x *ChallengeEvent) GetWordsChallenged() []string {
	if x != nil {
		return x.WordsChallenged
	}
	return nil
}

func (x *ChallengeEvent) GetScoreBonus() int32 {
	if x != nil {
		return x.ScoreBonus
	}
	return 0
}

func (x *ChallengeEvent) GetPlayValid() bool {
	if x != nil {
		return x.PlayValid
	}
	return false
}

type ExchangeEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// for cases where we don't know what tiles they exchanged, there should be
	// a number.
	//
	// Types that are assignable to Exchanged:
	//
	//	*ExchangeEvent_ExchangedRack
	//	*ExchangeEvent_NumExchanged
	Exchanged isExchangeEvent_Exchanged `protobuf_oneof:"exchanged"`
}

func (x *ExchangeEvent) Reset() {
	*x = ExchangeEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cgh_cgh_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExchangeEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExchangeEvent) ProtoMessage() {}

func (x *ExchangeEvent) ProtoReflect() protoreflect.Message {
	mi := &file_cgh_cgh_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExchangeEvent.ProtoReflect.Descriptor instead.
func (*ExchangeEvent) Descriptor() ([]byte, []int) {
	return file_cgh_cgh_proto_rawDescGZIP(), []int{5}
}

func (m *ExchangeEvent) GetExchanged() isExchangeEvent_Exchanged {
	if m != nil {
		return m.Exchanged
	}
	return nil
}

func (x *ExchangeEvent) GetExchangedRack() string {
	if x, ok := x.GetExchanged().(*ExchangeEvent_ExchangedRack); ok {
		return x.ExchangedRack
	}
	return ""
}

func (x *ExchangeEvent) GetNumExchanged() int32 {
	if x, ok := x.GetExchanged().(*ExchangeEvent_NumExchanged); ok {
		return x.NumExchanged
	}
	return 0
}

type isExchangeEvent_Exchanged interface {
	isExchangeEvent_Exchanged()
}

type ExchangeEvent_ExchangedRack struct {
	ExchangedRack string `protobuf:"bytes,1,opt,name=exchanged_rack,json=exchangedRack,proto3,oneof"`
}

type ExchangeEvent_NumExchanged struct {
	NumExchanged int32 `protobuf:"varint,2,opt,name=num_exchanged,json=numExchanged,proto3,oneof"`
}

func (*ExchangeEvent_ExchangedRack) isExchangeEvent_Exchanged() {}

func (*ExchangeEvent_NumExchanged) isExchangeEvent_Exchanged() {}

type TilePlayEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// coordinates should be specified as A13 or 7N, for example. If the number
	// is first, the play is horizontal. If the letter is first, the play is
	// vertical.
	Coordinates string `protobuf:"bytes,1,opt,name=coordinates,proto3" json:"coordinates,omitempty"`
	// the play should be specified as the tiles of a word. Previously played
	// tiles should not be specified with parentheses or dots; use the letter
	// directly. Blanks should be in lowercase.
	Play  string `protobuf:"bytes,2,opt,name=play,proto3" json:"play,omitempty"`
	Score int32  `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
	// if the play was incorrectly scored, this field should have the score
	// agreed on by the players.
	//
	// Types that are assignable to WrongScore:
	//
	//	*TilePlayEvent_ScoreIncorrect
	//	*TilePlayEvent_ScoredAs
	WrongScore isTilePlayEvent_WrongScore `protobuf_oneof:"wrong_score"`
}

func (x *TilePlayEvent) Reset() {
	*x = TilePlayEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cgh_cgh_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TilePlayEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TilePlayEvent) ProtoMessage() {}

func (x *TilePlayEvent) ProtoReflect() protoreflect.Message {
	mi := &file_cgh_cgh_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TilePlayEvent.ProtoReflect.Descriptor instead.
func (*TilePlayEvent) Descriptor() ([]byte, []int) {
	return file_cgh_cgh_proto_rawDescGZIP(), []int{6}
}

func (x *TilePlayEvent) GetCoordinates() string {
	if x != nil {
		return x.Coordinates
	}
	return ""
}

func (x *TilePlayEvent) GetPlay() string {
	if x != nil {
		return x.Play
	}
	return ""
}

func (x *TilePlayEvent) GetScore() int32 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (m *TilePlayEvent) GetWrongScore() isTilePlayEvent_WrongScore {
	if m != nil {
		return m.WrongScore
	}
	return nil
}

func (x *TilePlayEvent) GetScoreIncorrect() bool {
	if x, ok := x.GetWrongScore().(*TilePlayEvent_ScoreIncorrect); ok {
		return x.ScoreIncorrect
	}
	return false
}

func (x *TilePlayEvent) GetScoredAs() int32 {
	if x, ok := x.GetWrongScore().(*TilePlayEvent_ScoredAs); ok {
		return x.ScoredAs
	}
	return 0
}

type isTilePlayEvent_WrongScore interface {
	isTilePlayEvent_WrongScore()
}

type TilePlayEvent_ScoreIncorrect struct {
	ScoreIncorrect bool `protobuf:"varint,4,opt,name=score_incorrect,json=scoreIncorrect,proto3,oneof"`
}

type TilePlayEvent_ScoredAs struct {
	ScoredAs int32 `protobuf:"varint,5,opt,name=scored_as,json=scoredAs,proto3,oneof"`
}

func (*TilePlayEvent_ScoreIncorrect) isTilePlayEvent_WrongScore() {}

func (*TilePlayEvent_ScoredAs) isTilePlayEvent_WrongScore() {}

type GameEndEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	EndgameRackBonus int32 `protobuf:"varint,1,opt,name=endgame_rack_bonus,json=endgameRackBonus,proto3" json:"endgame_rack_bonus,omitempty"`
	// for rulesets where one player gains points and the other loses points,
	// we should have two GameEndEvents. This can also occur if the game
	// ended by accumulation of zero-pt turns.
	EndgamePointsLost int32 `protobuf:"varint,2,opt,name=endgame_points_lost,json=endgamePointsLost,proto3" json:"endgame_points_lost,omitempty"`
	// points_lost_on_time should be shown for each player if applicable.
	PointsLostOnTime int32 `protobuf:"varint,3,opt,name=points_lost_on_time,json=pointsLostOnTime,proto3" json:"points_lost_on_time,omitempty"`
}

func (x *GameEndEvent) Reset() {
	*x = GameEndEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cgh_cgh_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GameEndEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GameEndEvent) ProtoMessage() {}

func (x *GameEndEvent) ProtoReflect() protoreflect.Message {
	mi := &file_cgh_cgh_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GameEndEvent.ProtoReflect.Descriptor instead.
func (*GameEndEvent) Descriptor() ([]byte, []int) {
	return file_cgh_cgh_proto_rawDescGZIP(), []int{7}
}

func (x *GameEndEvent) GetEndgameRackBonus() int32 {
	if x != nil {
		return x.EndgameRackBonus
	}
	return 0
}

func (x *GameEndEvent) GetEndgamePointsLost() int32 {
	if x != nil {
		return x.EndgamePointsLost
	}
	return 0
}

func (x *GameEndEvent) GetPointsLostOnTime() int32 {
	if x != nil {
		return x.PointsLostOnTime
	}
	return 0
}

type OverdrawEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	RackThrownIn string `protobuf:"bytes,1,opt,name=rack_thrown_in,json=rackThrownIn,proto3" json:"rack_thrown_in,omitempty"`
}

func (x *OverdrawEvent) Reset() {
	*x = OverdrawEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cgh_cgh_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OverdrawEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OverdrawEvent) ProtoMessage() {}

func (x *OverdrawEvent) ProtoReflect() protoreflect.Message {
	mi := &file_cgh_cgh_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OverdrawEvent.ProtoReflect.Descriptor instead.
func (*OverdrawEvent) Descriptor() ([]byte, []int) {
	return file_cgh_cgh_proto_rawDescGZIP(), []int{8}
}

func (x *OverdrawEvent) GetRackThrownIn() string {
	if x != nil {
		return x.RackThrownIn
	}
	return ""
}

var File_cgh_cgh_proto protoreflect.FileDescriptor

var file_cgh_cgh_proto_rawDesc = []byte{
	0x0a, 0x0d, 0x63, 0x67, 0x68, 0x2f, 0x63, 0x67, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x16, 0x77, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x73, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x5f, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x73, 0x22, 0x45, 0x0a, 0x0a, 0x50, 0x6c, 0x61, 0x79, 0x65,
	0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1a, 0x0a, 0x08, 0x6e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d,
	0x65, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x65, 0x61, 0x6c, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x65, 0x61, 0x6c, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0xdd,
	0x05, 0x0a, 0x14, 0x43, 0x72, 0x6f, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x47, 0x61, 0x6d, 0x65,
	0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x12, 0x42, 0x0a, 0x06, 0x65, 0x76, 0x65, 0x6e, 0x74,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x77, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x73, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x73,
	0x2e, 0x43, 0x72, 0x6f, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x47, 0x61, 0x6d, 0x65, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x52, 0x06, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x3c, 0x0a, 0x07, 0x70,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x77,
	0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x73, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x5f, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x63, 0x6f, 0x6c, 0x73, 0x2e, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f,
	0x52, 0x07, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x6c, 0x65, 0x78,
	0x69, 0x63, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6c, 0x65, 0x78, 0x69,
	0x63, 0x6f, 0x6e, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x12, 0x21, 0x0a,
	0x0c, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x5f, 0x6c, 0x61, 0x79, 0x6f, 0x75, 0x74, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0b, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x4c, 0x61, 0x79, 0x6f, 0x75, 0x74,
	0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x2f, 0x0a, 0x13, 0x6c, 0x65, 0x74, 0x74, 0x65, 0x72, 0x5f, 0x64, 0x69, 0x73,
	0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x12, 0x6c, 0x65, 0x74, 0x74, 0x65, 0x72, 0x44, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74,
	0x69, 0x6f, 0x6e, 0x12, 0x4c, 0x0a, 0x0e, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65,
	0x5f, 0x72, 0x75, 0x6c, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x25, 0x2e, 0x77, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x73, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x63, 0x6f, 0x6c, 0x73, 0x2e, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x52, 0x75,
	0x6c, 0x65, 0x52, 0x0d, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x52, 0x75, 0x6c,
	0x65, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x67,
	0x70, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e,
	0x67, 0x43, 0x67, 0x70, 0x12, 0x28, 0x0a, 0x10, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6b, 0x6e, 0x6f,
	0x77, 0x6e, 0x5f, 0x72, 0x61, 0x63, 0x6b, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0e,
	0x6c, 0x61, 0x73, 0x74, 0x4b, 0x6e, 0x6f, 0x77, 0x6e, 0x52, 0x61, 0x63, 0x6b, 0x73, 0x12, 0x23,
	0x0a, 0x0d, 0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18,
	0x0b, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0c, 0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x54,
	0x69, 0x6d, 0x65, 0x12, 0x27, 0x0a, 0x0f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x69, 0x6e, 0x63, 0x72,
	0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0e, 0x74, 0x69,
	0x6d, 0x65, 0x49, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x66, 0x0a, 0x18,
	0x65, 0x6e, 0x64, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x72, 0x61, 0x63, 0x6b, 0x5f, 0x70, 0x6f, 0x69,
	0x6e, 0x74, 0x73, 0x5f, 0x72, 0x75, 0x6c, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2d,
	0x2e, 0x77, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x73, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x5f, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x73, 0x2e, 0x45, 0x6e, 0x64, 0x67, 0x61, 0x6d, 0x65, 0x52,
	0x61, 0x63, 0x6b, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x52, 0x75, 0x6c, 0x65, 0x52, 0x15, 0x65,
	0x6e, 0x64, 0x67, 0x61, 0x6d, 0x65, 0x52, 0x61, 0x63, 0x6b, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x73,
	0x52, 0x75, 0x6c, 0x65, 0x12, 0x48, 0x0a, 0x22, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x5f, 0x6f,
	0x66, 0x5f, 0x7a, 0x65, 0x72, 0x6f, 0x70, 0x74, 0x5f, 0x74, 0x75, 0x72, 0x6e, 0x73, 0x5f, 0x74,
	0x6f, 0x5f, 0x65, 0x6e, 0x64, 0x5f, 0x67, 0x61, 0x6d, 0x65, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x1c, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x4f, 0x66, 0x5a, 0x65, 0x72, 0x6f, 0x70, 0x74,
	0x54, 0x75, 0x72, 0x6e, 0x73, 0x54, 0x6f, 0x45, 0x6e, 0x64, 0x47, 0x61, 0x6d, 0x65, 0x22, 0x85,
	0x05, 0x0a, 0x12, 0x43, 0x72, 0x6f, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x47, 0x61, 0x6d, 0x65,
	0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x6e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d,
	0x65, 0x12, 0x12, 0x0a, 0x04, 0x72, 0x61, 0x63, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x04, 0x72, 0x61, 0x63, 0x6b, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73,
	0x63, 0x6f, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x74, 0x6f, 0x74, 0x61,
	0x6c, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x72,
	0x65, 0x6d, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0d,
	0x74, 0x69, 0x6d, 0x65, 0x52, 0x65, 0x6d, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x12, 0x42, 0x0a,
	0x0a, 0x70, 0x61, 0x73, 0x73, 0x5f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x21, 0x2e, 0x77, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x73, 0x5f, 0x6f, 0x70, 0x65, 0x6e,
	0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x73, 0x2e, 0x50, 0x61, 0x73, 0x73, 0x45,
	0x76, 0x65, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x09, 0x70, 0x61, 0x73, 0x73, 0x45, 0x76, 0x65, 0x6e,
	0x74, 0x12, 0x51, 0x0a, 0x0f, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x5f, 0x65,
	0x76, 0x65, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x77, 0x6f, 0x6f,
	0x67, 0x6c, 0x65, 0x73, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x73, 0x2e, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x45, 0x76, 0x65,
	0x6e, 0x74, 0x48, 0x00, 0x52, 0x0e, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x45,
	0x76, 0x65, 0x6e, 0x74, 0x12, 0x4e, 0x0a, 0x0e, 0x65, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65,
	0x5f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x77,
	0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x73, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x5f, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x63, 0x6f, 0x6c, 0x73, 0x2e, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x0d, 0x65, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x45,
	0x76, 0x65, 0x6e, 0x74, 0x12, 0x4f, 0x0a, 0x0f, 0x74, 0x69, 0x6c, 0x65, 0x5f, 0x70, 0x6c, 0x61,
	0x79, 0x5f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e,
	0x77, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x73, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x5f, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x73, 0x2e, 0x54, 0x69, 0x6c, 0x65, 0x50, 0x6c, 0x61, 0x79, 0x45,
	0x76, 0x65, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x0d, 0x74, 0x69, 0x6c, 0x65, 0x50, 0x6c, 0x61, 0x79,
	0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x4c, 0x0a, 0x0e, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x65, 0x6e,
	0x64, 0x5f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e,
	0x77, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x73, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x5f, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x73, 0x2e, 0x47, 0x61, 0x6d, 0x65, 0x45, 0x6e, 0x64, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x48, 0x00, 0x52, 0x0c, 0x67, 0x61, 0x6d, 0x65, 0x45, 0x6e, 0x64, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x12, 0x4e, 0x0a, 0x0e, 0x6f, 0x76, 0x65, 0x72, 0x64, 0x72, 0x61, 0x77, 0x5f,
	0x65, 0x76, 0x65, 0x6e, 0x74, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x77, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x73, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x63, 0x6f, 0x6c, 0x73, 0x2e, 0x4f, 0x76, 0x65, 0x72, 0x64, 0x72, 0x61, 0x77, 0x45, 0x76, 0x65,
	0x6e, 0x74, 0x48, 0x00, 0x52, 0x0d, 0x6f, 0x76, 0x65, 0x72, 0x64, 0x72, 0x61, 0x77, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x42, 0x07, 0x0a,
	0x05, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x22, 0x0b, 0x0a, 0x09, 0x50, 0x61, 0x73, 0x73, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x22, 0x7b, 0x0a, 0x0e, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65,
	0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x29, 0x0a, 0x10, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x5f, 0x63,
	0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x64, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52,
	0x0f, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x64,
	0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x62, 0x6f, 0x6e, 0x75, 0x73, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x6f, 0x6e, 0x75,
	0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x70, 0x6c, 0x61, 0x79, 0x5f, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x70, 0x6c, 0x61, 0x79, 0x56, 0x61, 0x6c, 0x69, 0x64,
	0x22, 0x6c, 0x0a, 0x0d, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x45, 0x76, 0x65, 0x6e,
	0x74, 0x12, 0x27, 0x0a, 0x0e, 0x65, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x5f, 0x72,
	0x61, 0x63, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x0d, 0x65, 0x78, 0x63,
	0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x52, 0x61, 0x63, 0x6b, 0x12, 0x25, 0x0a, 0x0d, 0x6e, 0x75,
	0x6d, 0x5f, 0x65, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x05, 0x48, 0x00, 0x52, 0x0c, 0x6e, 0x75, 0x6d, 0x45, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65,
	0x64, 0x42, 0x0b, 0x0a, 0x09, 0x65, 0x78, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x22, 0xb4,
	0x01, 0x0a, 0x0d, 0x54, 0x69, 0x6c, 0x65, 0x50, 0x6c, 0x61, 0x79, 0x45, 0x76, 0x65, 0x6e, 0x74,
	0x12, 0x20, 0x0a, 0x0b, 0x63, 0x6f, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x73, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x63, 0x6f, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61, 0x74,
	0x65, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x6c, 0x61, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x04, 0x70, 0x6c, 0x61, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x12, 0x29, 0x0a, 0x0f,
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x69, 0x6e, 0x63, 0x6f, 0x72, 0x72, 0x65, 0x63, 0x74, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x0e, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x49, 0x6e,
	0x63, 0x6f, 0x72, 0x72, 0x65, 0x63, 0x74, 0x12, 0x1d, 0x0a, 0x09, 0x73, 0x63, 0x6f, 0x72, 0x65,
	0x64, 0x5f, 0x61, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x08, 0x73, 0x63,
	0x6f, 0x72, 0x65, 0x64, 0x41, 0x73, 0x42, 0x0d, 0x0a, 0x0b, 0x77, 0x72, 0x6f, 0x6e, 0x67, 0x5f,
	0x73, 0x63, 0x6f, 0x72, 0x65, 0x22, 0x9b, 0x01, 0x0a, 0x0c, 0x47, 0x61, 0x6d, 0x65, 0x45, 0x6e,
	0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x2c, 0x0a, 0x12, 0x65, 0x6e, 0x64, 0x67, 0x61, 0x6d,
	0x65, 0x5f, 0x72, 0x61, 0x63, 0x6b, 0x5f, 0x62, 0x6f, 0x6e, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x10, 0x65, 0x6e, 0x64, 0x67, 0x61, 0x6d, 0x65, 0x52, 0x61, 0x63, 0x6b, 0x42,
	0x6f, 0x6e, 0x75, 0x73, 0x12, 0x2e, 0x0a, 0x13, 0x65, 0x6e, 0x64, 0x67, 0x61, 0x6d, 0x65, 0x5f,
	0x70, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x5f, 0x6c, 0x6f, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x11, 0x65, 0x6e, 0x64, 0x67, 0x61, 0x6d, 0x65, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x73,
	0x4c, 0x6f, 0x73, 0x74, 0x12, 0x2d, 0x0a, 0x13, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x5f, 0x6c,
	0x6f, 0x73, 0x74, 0x5f, 0x6f, 0x6e, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x10, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x4c, 0x6f, 0x73, 0x74, 0x4f, 0x6e, 0x54,
	0x69, 0x6d, 0x65, 0x22, 0x35, 0x0a, 0x0d, 0x4f, 0x76, 0x65, 0x72, 0x64, 0x72, 0x61, 0x77, 0x45,
	0x76, 0x65, 0x6e, 0x74, 0x12, 0x24, 0x0a, 0x0e, 0x72, 0x61, 0x63, 0x6b, 0x5f, 0x74, 0x68, 0x72,
	0x6f, 0x77, 0x6e, 0x5f, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x72, 0x61,
	0x63, 0x6b, 0x54, 0x68, 0x72, 0x6f, 0x77, 0x6e, 0x49, 0x6e, 0x2a, 0x52, 0x0a, 0x0d, 0x43, 0x68,
	0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x0a, 0x0a, 0x06, 0x53,
	0x49, 0x4e, 0x47, 0x4c, 0x45, 0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x44, 0x4f, 0x55, 0x42, 0x4c,
	0x45, 0x10, 0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x46, 0x49, 0x56, 0x45, 0x5f, 0x50, 0x4f, 0x49, 0x4e,
	0x54, 0x10, 0x02, 0x12, 0x0d, 0x0a, 0x09, 0x54, 0x45, 0x4e, 0x5f, 0x50, 0x4f, 0x49, 0x4e, 0x54,
	0x10, 0x03, 0x12, 0x0a, 0x0a, 0x06, 0x54, 0x52, 0x49, 0x50, 0x4c, 0x45, 0x10, 0x04, 0x2a, 0x3a,
	0x0a, 0x15, 0x45, 0x6e, 0x64, 0x67, 0x61, 0x6d, 0x65, 0x52, 0x61, 0x63, 0x6b, 0x50, 0x6f, 0x69,
	0x6e, 0x74, 0x73, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x0e, 0x0a, 0x0a, 0x44, 0x4f, 0x55, 0x42, 0x4c,
	0x45, 0x5f, 0x50, 0x54, 0x53, 0x10, 0x00, 0x12, 0x11, 0x0a, 0x0d, 0x50, 0x4c, 0x55, 0x53, 0x4d,
	0x49, 0x4e, 0x55, 0x53, 0x5f, 0x50, 0x54, 0x53, 0x10, 0x01, 0x42, 0x2e, 0x5a, 0x2c, 0x67, 0x69,
	0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x77, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x73,
	0x2d, 0x69, 0x6f, 0x2f, 0x6f, 0x70, 0x65, 0x6e, 0x2d, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f,
	0x6c, 0x73, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x63, 0x67, 0x68, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x33,
}

var (
	file_cgh_cgh_proto_rawDescOnce sync.Once
	file_cgh_cgh_proto_rawDescData = file_cgh_cgh_proto_rawDesc
)

func file_cgh_cgh_proto_rawDescGZIP() []byte {
	file_cgh_cgh_proto_rawDescOnce.Do(func() {
		file_cgh_cgh_proto_rawDescData = protoimpl.X.CompressGZIP(file_cgh_cgh_proto_rawDescData)
	})
	return file_cgh_cgh_proto_rawDescData
}

var file_cgh_cgh_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_cgh_cgh_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_cgh_cgh_proto_goTypes = []interface{}{
	(ChallengeRule)(0),           // 0: woogles_open_protocols.ChallengeRule
	(EndgameRackPointsRule)(0),   // 1: woogles_open_protocols.EndgameRackPointsRule
	(*PlayerInfo)(nil),           // 2: woogles_open_protocols.PlayerInfo
	(*CrosswordGameHistory)(nil), // 3: woogles_open_protocols.CrosswordGameHistory
	(*CrosswordGameEvent)(nil),   // 4: woogles_open_protocols.CrosswordGameEvent
	(*PassEvent)(nil),            // 5: woogles_open_protocols.PassEvent
	(*ChallengeEvent)(nil),       // 6: woogles_open_protocols.ChallengeEvent
	(*ExchangeEvent)(nil),        // 7: woogles_open_protocols.ExchangeEvent
	(*TilePlayEvent)(nil),        // 8: woogles_open_protocols.TilePlayEvent
	(*GameEndEvent)(nil),         // 9: woogles_open_protocols.GameEndEvent
	(*OverdrawEvent)(nil),        // 10: woogles_open_protocols.OverdrawEvent
}
var file_cgh_cgh_proto_depIdxs = []int32{
	4,  // 0: woogles_open_protocols.CrosswordGameHistory.events:type_name -> woogles_open_protocols.CrosswordGameEvent
	2,  // 1: woogles_open_protocols.CrosswordGameHistory.players:type_name -> woogles_open_protocols.PlayerInfo
	0,  // 2: woogles_open_protocols.CrosswordGameHistory.challenge_rule:type_name -> woogles_open_protocols.ChallengeRule
	1,  // 3: woogles_open_protocols.CrosswordGameHistory.endgame_rack_points_rule:type_name -> woogles_open_protocols.EndgameRackPointsRule
	5,  // 4: woogles_open_protocols.CrosswordGameEvent.pass_event:type_name -> woogles_open_protocols.PassEvent
	6,  // 5: woogles_open_protocols.CrosswordGameEvent.challenge_event:type_name -> woogles_open_protocols.ChallengeEvent
	7,  // 6: woogles_open_protocols.CrosswordGameEvent.exchange_event:type_name -> woogles_open_protocols.ExchangeEvent
	8,  // 7: woogles_open_protocols.CrosswordGameEvent.tile_play_event:type_name -> woogles_open_protocols.TilePlayEvent
	9,  // 8: woogles_open_protocols.CrosswordGameEvent.game_end_event:type_name -> woogles_open_protocols.GameEndEvent
	10, // 9: woogles_open_protocols.CrosswordGameEvent.overdraw_event:type_name -> woogles_open_protocols.OverdrawEvent
	10, // [10:10] is the sub-list for method output_type
	10, // [10:10] is the sub-list for method input_type
	10, // [10:10] is the sub-list for extension type_name
	10, // [10:10] is the sub-list for extension extendee
	0,  // [0:10] is the sub-list for field type_name
}

func init() { file_cgh_cgh_proto_init() }
func file_cgh_cgh_proto_init() {
	if File_cgh_cgh_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_cgh_cgh_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PlayerInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cgh_cgh_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CrosswordGameHistory); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cgh_cgh_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CrosswordGameEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cgh_cgh_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PassEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cgh_cgh_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ChallengeEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cgh_cgh_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExchangeEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cgh_cgh_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TilePlayEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cgh_cgh_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GameEndEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cgh_cgh_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OverdrawEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_cgh_cgh_proto_msgTypes[2].OneofWrappers = []interface{}{
		(*CrosswordGameEvent_PassEvent)(nil),
		(*CrosswordGameEvent_ChallengeEvent)(nil),
		(*CrosswordGameEvent_ExchangeEvent)(nil),
		(*CrosswordGameEvent_TilePlayEvent)(nil),
		(*CrosswordGameEvent_GameEndEvent)(nil),
		(*CrosswordGameEvent_OverdrawEvent)(nil),
	}
	file_cgh_cgh_proto_msgTypes[5].OneofWrappers = []interface{}{
		(*ExchangeEvent_ExchangedRack)(nil),
		(*ExchangeEvent_NumExchanged)(nil),
	}
	file_cgh_cgh_proto_msgTypes[6].OneofWrappers = []interface{}{
		(*TilePlayEvent_ScoreIncorrect)(nil),
		(*TilePlayEvent_ScoredAs)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_cgh_cgh_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_cgh_cgh_proto_goTypes,
		DependencyIndexes: file_cgh_cgh_proto_depIdxs,
		EnumInfos:         file_cgh_cgh_proto_enumTypes,
		MessageInfos:      file_cgh_cgh_proto_msgTypes,
	}.Build()
	File_cgh_cgh_proto = out.File
	file_cgh_cgh_proto_rawDesc = nil
	file_cgh_cgh_proto_goTypes = nil
	file_cgh_cgh_proto_depIdxs = nil
}
